AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Binder - Presigned URL Lambda

Parameters:
  Env:
    Type: String
    AllowedValues: [prod, stg]

  LambdaFunctionName:
    Type: String
    Default: binder-presign-lambda

  LambdaRuntime:
    Type: String
    Default: python3.12

  LambdaTimeout:
    Type: Number
    Default: 10

  LambdaMemorySize:
    Type: Number
    Default: 256

  LambdaReservedConcurrency:
    Type: Number
    Default: 5

  BucketNamePrefix:
    Type: String
    Default: binder
    Description: Prefix of S3 bucket name (bucket = prefix-env-CN)

Resources:
  # ------------------------------------------------------------
  # IAM Role for Lambda
  # ------------------------------------------------------------
  BinderLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "binder-lambda-execution-role-${Env}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BinderPresignS3Policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowPresignForBinderBuckets
                Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${BucketNamePrefix}-${Env}-*"
                  - !Sub "arn:aws:s3:::${BucketNamePrefix}-${Env}-*/*"

  # ------------------------------------------------------------
  # Lambda Function
  # ------------------------------------------------------------
  BinderPresignLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${LambdaFunctionName}-${Env}"
      Runtime: !Ref LambdaRuntime
      Handler: index.handler
      Role: !GetAtt BinderLambdaExecutionRole.Arn
      Timeout: !Ref LambdaTimeout
      MemorySize: !Ref LambdaMemorySize
      ReservedConcurrentExecutions: !Ref LambdaReservedConcurrency
      Environment:
        Variables:
          BINDER_ENV: !Ref Env
          BUCKET_PREFIX: !Ref BucketNamePrefix
      Code:
        ZipFile: |
          import boto3, json, os

          s3 = boto3.client("s3")

          def extract_cn(subject_dn: str) -> str:
              for part in subject_dn.split(","):
                  part = part.strip()
                  if part.startswith("CN="):
                      return part.replace("CN=", "")
              raise ValueError("CN not found in subjectDN")

          def get_subject_dn(event) -> str:
              rc = event.get("requestContext", {})
              auth = rc.get("authentication", {})
              mtls = auth.get("mtls", {})
              client_cert = mtls.get("clientCert") or auth.get("clientCert") or {}
              subject = client_cert.get("subjectDN")
              if subject:
                  return subject
              raise ValueError("Client certificate not found")

          def bucket_from_event(event) -> str:
              env = os.environ.get("BINDER_ENV")
              prefix = os.environ.get("BUCKET_PREFIX")
              cn = extract_cn(get_subject_dn(event))
              return f"{prefix}-{env}-{cn}"

          def response(code, body):
              return {
                  "statusCode": code,
                  "headers": {"Content-Type": "application/json"},
                  "body": json.dumps(body)
              }

          def handler(event, context):
              try:
                  method = event["requestContext"]["http"]["method"]
                  params = event.get("pathParameters") or {}
                  filename = params.get("filename")
                  bucket = bucket_from_event(event)

                  if method == "PUT" and filename:
                      url = s3.generate_presigned_url(
                          "put_object",
                          Params={"Bucket": bucket, "Key": filename},
                          ExpiresIn=900
                      )
                      return response(200, {"operation": "upload", "bucket": bucket, "key": filename, "url": url})

                  if method == "GET" and filename:
                      url = s3.generate_presigned_url(
                          "get_object",
                          Params={"Bucket": bucket, "Key": filename},
                          ExpiresIn=300
                      )
                      return response(200, {"operation": "download", "bucket": bucket, "key": filename, "url": url})

                  if method == "DELETE" and filename:
                      url = s3.generate_presigned_url(
                          "delete_object",
                          Params={"Bucket": bucket, "Key": filename},
                          ExpiresIn=300
                      )
                      return response(200, {"operation": "delete", "bucket": bucket, "key": filename, "url": url})

                  if method == "GET" and not filename:
                      url = s3.generate_presigned_url(
                          "list_objects_v2",
                          Params={"Bucket": bucket},
                          ExpiresIn=300
                      )
                      return response(200, {"operation": "list", "bucket": bucket, "url": url})

                  return response(400, {"message": "Unsupported request"})

              except ValueError as e:
                  return response(401, {"message": str(e)})
              except Exception:
                  return response(500, {"message": "Internal server error"})

Outputs:
  LambdaFunctionArn:
    Description: ARN of presign Lambda function
    Value: !GetAtt BinderPresignLambda.Arn

  LambdaExecutionRoleArn:
    Description: IAM role ARN for Lambda
    Value: !GetAtt BinderLambdaExecutionRole.Arn
