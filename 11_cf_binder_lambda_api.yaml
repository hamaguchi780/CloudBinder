AWSTemplateFormatVersion: "2010-09-09"
Description: Binder - Core (Lambda + HTTP API(mTLS))

Parameters:
  Env:
    Type: String
    AllowedValues: [prod, stg]

  ApiNamePrefix:
    Type: String
    Default: binder

  StageName:
    Type: String
    Default: "$default"
    Description: Use $default for HTTP API

  DomainName:
    Type: String
    Description: e.g. binder-prod.example.com

  CertificateArn:
    Type: String
    Description: ACM certificate ARN for the custom domain

  TrustStoreBucket:
    Type: String
  TrustStoreKey:
    Type: String

  ApiRateLimit:
    Type: Number
    Default: 2
  ApiBurstLimit:
    Type: Number
    Default: 5

  LambdaFunctionName:
    Type: String
    Default: binder-presign-lambda
  LambdaRuntime:
    Type: String
    Default: python3.12
  LambdaTimeout:
    Type: Number
    Default: 10
  LambdaMemorySize:
    Type: Number
    Default: 256
  LambdaReservedConcurrency:
    Type: Number
    Default: 5

Resources:
  BinderLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "binder-lambda-execution-role-${Env}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BinderPresignS3Policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowPresignForBinderBuckets
                Effect: Allow
                Action: [s3:PutObject, s3:GetObject, s3:DeleteObject, s3:ListBucket]
                Resource:
                  - arn:aws:s3:::binder-*
                  - arn:aws:s3:::binder-*/*

  BinderPresignLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${LambdaFunctionName}-${Env}"
      Runtime: !Ref LambdaRuntime
      Handler: index.handler
      Role: !GetAtt BinderLambdaExecutionRole.Arn
      Timeout: !Ref LambdaTimeout
      MemorySize: !Ref LambdaMemorySize
      ReservedConcurrentExecutions: !Ref LambdaReservedConcurrency
      Environment:
        Variables:
          BINDER_ENV: !Ref Env
      Code:
        ZipFile: |
          import boto3, json, os

          s3 = boto3.client("s3")

          def extract_cn(subject_dn: str) -> str:
              for part in subject_dn.split(","):
                  part = part.strip()
                  if part.startswith("CN="):
                      return part.replace("CN=", "")
              raise ValueError("CN not found in subjectDN")

          def get_subject_dn(event) -> str:
              # HTTP API v2: requestContext.authentication.mtls.clientCert.subjectDN (or .clientCert)
              rc = (event.get("requestContext") or {})
              auth = (rc.get("authentication") or {})
              mtls = (auth.get("mtls") or {})
              cc = mtls.get("clientCert") or auth.get("clientCert") or {}
              subject = cc.get("subjectDN")
              if subject:
                  return subject
              raise ValueError("Client certificate not found")

          def bucket_from_event(event) -> str:
              env = os.environ.get("BINDER_ENV", "prod")
              cn = extract_cn(get_subject_dn(event))
              return f"binder-{env}-{cn}"

          def response(code, body_dict):
              return {
                  "statusCode": code,
                  "headers": {"Content-Type": "application/json"},
                  "body": json.dumps(body_dict)
              }

          def handler(event, context):
              try:
                  method = event["requestContext"]["http"]["method"]
                  path_params = event.get("pathParameters") or {}
                  filename = path_params.get("filename")
                  bucket = bucket_from_event(event)

                  if method == "PUT" and filename:
                      url = s3.generate_presigned_url(
                          "put_object",
                          Params={"Bucket": bucket, "Key": filename},
                          ExpiresIn=900
                      )
                      return response(200, {"operation":"upload","bucket":bucket,"key":filename,"url":url})

                  if method == "GET" and filename:
                      url = s3.generate_presigned_url(
                          "get_object",
                          Params={"Bucket": bucket, "Key": filename},
                          ExpiresIn=300
                      )
                      return response(200, {"operation":"download","bucket":bucket,"key":filename,"url":url})

                  if method == "DELETE" and filename:
                      url = s3.generate_presigned_url(
                          "delete_object",
                          Params={"Bucket": bucket, "Key": filename},
                          ExpiresIn=300
                      )
                      return response(200, {"operation":"delete","bucket":bucket,"key":filename,"url":url})

                  if method == "GET" and not filename:
                      url = s3.generate_presigned_url(
                          "list_objects_v2",
                          Params={"Bucket": bucket},
                          ExpiresIn=300
                      )
                      return response(200, {"operation":"list","bucket":bucket,"url":url})

                  return response(400, {"message":"Unsupported request"})

              except ValueError as e:
                  return response(401, {"message": str(e)})
              except Exception:
                  return response(500, {"message":"Internal server error"})

  BinderHttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub "${ApiNamePrefix}-${Env}-http-api"
      ProtocolType: HTTP

  BinderLambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref BinderHttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt BinderPresignLambda.Arn
      PayloadFormatVersion: "2.0"

  PutRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref BinderHttpApi
      RouteKey: "PUT /files/{filename}"
      Target: !Sub "integrations/${BinderLambdaIntegration}"

  GetRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref BinderHttpApi
      RouteKey: "GET /files/{filename}"
      Target: !Sub "integrations/${BinderLambdaIntegration}"

  DeleteRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref BinderHttpApi
      RouteKey: "DELETE /files/{filename}"
      Target: !Sub "integrations/${BinderLambdaIntegration}"

  ListRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref BinderHttpApi
      RouteKey: "GET /files"
      Target: !Sub "integrations/${BinderLambdaIntegration}"

  BinderApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref BinderHttpApi
      StageName: !Ref StageName
      AutoDeploy: true
      DefaultRouteSettings:
        ThrottlingRateLimit: !Ref ApiRateLimit
        ThrottlingBurstLimit: !Ref ApiBurstLimit

  BinderApiDomain:
    Type: AWS::ApiGatewayV2::DomainName
    Properties:
      DomainName: !Ref DomainName
      DomainNameConfigurations:
        - CertificateArn: !Ref CertificateArn
          EndpointType: REGIONAL
      MutualTlsAuthentication:
        TruststoreUri: !Sub "s3://${TrustStoreBucket}/${TrustStoreKey}"

  BinderApiMapping:
    Type: AWS::ApiGatewayV2::ApiMapping
    DependsOn: BinderApiStage
    Properties:
      ApiId: !Ref BinderHttpApi
      DomainName: !Ref BinderApiDomain
      Stage: !Ref StageName

  AllowInvokeLambda:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt BinderPresignLambda.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${BinderHttpApi}/*"

Outputs:
  LambdaFunctionArn:
    Value: !GetAtt BinderPresignLambda.Arn
  ApiDomainEndpoint:
    Value: !Sub "https://${DomainName}"